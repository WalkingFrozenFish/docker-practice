Проблема при билде, не находит директорию или не может сделать что то с ключем, не
может скопировать из одной директории в другую
https://github.com/dotnet/core/issues/3877



Посмотреть какие образы есть локально
docker images

Посмотреть какие контейнеры запущены в настоящий момент
docker ps


Запаковка приложения в образ (создание образа)
docker build -t hello-world .

-t hello-world тег, то как назовем новый образ
. текщая директория откуда собирать приложение (путь откуда собираем приложение, исходник)


Для того что бы докер понимал как собирать приложение, нужен Dockerfile

================Dockerfile================
Базовый образ, с которого начинаем сборку. Через двоеточие указывается тег, в данном случае версия 3.6
FROM python:3.6

Эта команда определяет то, что нужно выполнить, в данном случае создать папку
RUN mkdir -p /usr/src/app 

Это переход в каталог и выполнение начнется с этого каталога
WORKDIR /usr/src/app

Эта команда принимает два аргумента, первый это откужа копировать, а второй аргумент, это куда скопировать. В данном случае с текущей директории локальной машины скопировать все, и переместить в контейнер
COPY . /usr/src/app

Команда которая декларирует то, какой порт мы прокидываем. Так как контейнер это изолированная среда, то без проброса портов мы не сможем получить доступ к приложению
EXPOSE 8080

Команда которая говорит что нужно делать когда мы запустим контейнер. В данном случае запустить интерпретатор питона и передать ему название файла для исполнения
CMD ["python", "app.py"]
================Dockerfile================


Для запуска контейнеров есть команда
docker run IMAGE_NAME

Задание своего имени для контейнера
docker run --name CUSTOM_CONTAINER_COOL_NAME IMAGE_NAME
К примеру 
docker run --name hello hello-world-image



Посмотреть все контейнеры которые даже были остановлены
docker ps -a

Для удаления контейнера есть команда
docker rm CONTAINER_ID_OR_NAME
К примеру 
docker rm 7868be98988d


Для того что бы можно было запустить контейнер, и освободить терминал, есть команда. Эта команда позволит запустить контейнер в фоне, для этого используется флаг -d
docker run --name CUSTOM_CONTAINER_COOL_NAME -d IMAGE_NAME

Что бы остановить контейнер, есть команда
docker stop CONTAINER_ID_OR_NAME


Что бы контейнер сам удалился после того как выполнит свою работу, есть команда с флагом --rm
docker run --name CUSTOM_CONTAINER_COOL_NAME -d --rm IMAGE_NAME


Для того что бы мы могли пробросить порты, нам требуется немного изменить команду по запуску контейнета
docker run --name CUSTOM_NAME --rm -d -p 8080:8080 IMAGE_NAME
Первый порт, это порт локальной машины, на которой запущен докер, второй порт, это порт в докер контейнере
-p HOST_PORT:CONTAINER_PORT


Так как контейнер докер это изолированая среда и только для чтения, то мы просто так не можем менять данные. Но есть старый способ как можно сделать так, что бы данные сохранились, для этого можно примонтировать папку. Для этого можно изменить команду
docker run --name CUSTOM_NAME --rm -d -p 8080:8080 -v /c/Users/Олег/Desktop/dockerPractice/serverExample/resources:/somepython/resources IMAGE_NAME

Указывается флаг и через двоеточие два абсолютных пути, первый это абсолютный путь к папке на хостовой машине, а второй в контейнере
-v HOST_PATH:CONTAINER_PATH

Абсолютный путь на локальной машине
/c/Users/Олег/Desktop/dockerPractice/serverExample/resources
Абсолютный путь в контейнере, мы писали WORKDIR, и этот путь будет абсолютным, указываем этот путь и названия тех папок которые потребуются
/somepython/resources

Пример команды
docker run --name py -d --rm -p 8080:8080 -v /c/Users/Олег/Desktop/dockerPractice/serverExample/resources:/somepython/resources newpy



Для того что бы посмотреть какие volume есть у нас, есть команда
docker volume ls

Что бы создать volume, используется команда
docker volume create VOLUME_NAME

Для того что бы подключить volume к нашему контейнеру, немного изменим команду
docker run --name web -d --rm -p 8080:8080 -v web:/somepython/resources newpy

Вместо абсолютного пути локальной машины мы указываем название volume


Что бы удалить образ локально, используется эта команда
docker rmi IMAGE_NAME_OR_ID



Бывает что нам требуется запустить множество контейнеров с кучей параметров, это бывает не удобно, здесь нам поможет надстройка над докером
Эта надстройка называется docker-compose.yaml


================docker-compose.yaml================

Версия
version: "3"

Список volume которые будут использоваться, в данном случае mongo. Это нужно что бы данные которые хранятся в базе, не затерлись при удалении контейнера
volumes:
    mongodb_volume:

Список сервисов, которые требуется развернуть
services:
    Первый сервис
    youtube_statistic:
        Путь по которому мы будем собирать образ, именно собираем образ
        build: StatisticManager/
        
        Если локальная машина будет перезапущена, то с помощью этого пункта, мы указываем что бы докер автоматически поднял текущий контейнер
        restart: always

        Здесь указаны все переменные которые нам могут потребоваться
        environment:
            Здесь указали сервис в переменной, когда данный сервис поднимется, он будет доступен и к нему можно будет обратиться, в данном случае данный контейнер сможет получить доступ к контейрнеру в mongo, но извне нельзя будет получить доступ
            - MONGO_DB_ADDR=mongodb
            - MONGO_DB_PORT=27017
            - LANGUAGE=RU
            - BASE_REPORT_URL=http://example-url.com

    Второй сервис
    web_service:
        build: WebService/
        restart: always
        ports:
            - 8080:8080
        environment:
            - LOG_MODE=DEV
            - STORAGE_SERVICE_IMPL=MongodbService

    Третий сервис
    mongodb:
        Здесь берем образ mongo последней версии, то есть не собираем образ, а загружаем из докерхаб
        image: mongo:latest

        Примонтирование volume который захотим
        volumes:
            Указываем сам volume, затем папку в которую будет монитроваться
            Указан выше был vol
            - mongodb_volume:/data/db
        restart: always

================docker-compose.yaml================





Подключение к серверу без указания пароля. Для этого  потребуется сгенерировать ssh ключ, это можно сделать с помощью команды 
ssh-keygen -t rsa

Затем в корне папки .ssh требуется создать файл config, и поместить в него этот код

Название может быть любое
host ex
    Адрес сервера
    hostname 5.23.52.195
    
    Пользователь
    user root

    Приватный ключ который мы будем использовать
    IdentityFile ~/.ssh/example/example

Затем в настройках сервера добавляем публичный ssh ключ. Потом можем написать команду
ssh ex

После этого мы подключимся к серверу



В начале можно вручную склонировать репозиторий в котором есть compose файл, на сервер. Затем перейти в папку с проектом и запустить эту команду
docker-compose up -d

Эта команда запустит все контейнеры. Так же есть команда для остановки всех контейнеров
docker-compose down